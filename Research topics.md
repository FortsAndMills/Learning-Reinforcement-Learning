1) **Training-Playing**. Типичный алгоритм DQN на каждом шаге делает один ход в игре, одну итерацию обучения. При этом известно, что в том же Понге увеличение batch_size в 4 раза и совершение итерации обучения раз в 4 хода в игре ускоряет процесс обучения чуть ли не раза в два. Возможно ли настраивать этот гиперпараметр онлайн, то есть оптимизируя количество шагов в игре в зависимости, например, от лосса? Если лосс высокий, нейросеть ещё не выучила Q-функцию по имеющимся сэмплам, и получать новые пока рано - можно дообучиться, и наоборот.

2) **Distributed DQN**. Возможно, на этот вопрос частично ответ даётся в статье Ape-X (2018), но речь идёт о том, чтобы использовать процессоры для одновременной игры в нескольких средах. Первые эксперименты показали, что ускорения это не даёт: похоже, нужно корректировать количество итераций обучения после 1 шага в N играх (по логике, нужно делать N итераций, но есть подозрение, что нужно сильно меньше).

3) **Distributed Exploration**. Идея из облачков. В асинхронных алгоритмах, играющих параллельно несколько игр, возможно ли за играть все эти, скажем, 8 игр как-то по-разному? Желательно при этом, конечно, не иметь 8 нейросетей, но использовать как-то разные гиперпараметры, может быть, можно.

4) **Ensembling different losses**. Известно, что обучение нескольких нейросетей одним алгоритмом и последующее ансамблирование каким-нибудь банальным образом сильно помогает: например, если ответы нейросетей в некотором состоянии сильно различаются, то это состояние считается неисследованным (дисперсия между ответами сетей - отличная мера новизны/непонятности состояния). Тема сама по себе интересная (ансамблирование в RL), но ещё можно задаться вопросом, а можно ли ансамблировать разные алгоритмы, например, DQN, обученный на квадратичной функции потерь, на Huber-е, и ещё чём-нибудь... Ансамблировать, скажем, DQN и производные DQN, наверное, по большей части, ничего особого не даст, а ансамблировать DQN и A2C (независимо обучившиеся, скажем) - не очень понятно как.

5) **Dueling Categorical**. При создании радуги во время объединения Dueling DQN и Categorical DQN возник костылющий косяк, ломающий всю идею дуэльной архитектуры. Возможно, поэтому при удалении дэульной архитектуры из Rainbow качество в среднем якобы не проседает (согласно самим авторам статьи). Может, можно пофиксить.

6) **Noisy Net**. Добавление шума в сеть по формуле w = m + eps * sigma, где m и sigma - обучаемые параметры, самый универсальный способ exploration-а, плюс лишён гиперпараметров (это большой плюс). Однако, с инициализацией беда: нужно установить исходное значение сигм. Малое значение - нет exploration-а, большое значение - сходится долго. Поэтому по факту гиперпараметр есть, и даже очень плохой... Возникает вопрос: почему при большом значении шума сеть практически не сбрасывает среднее значение сигм. Есть подозрение, что дело в том, что sigma может в том числе прыгать вокруг нуля. Идея - заменить sigma на ReLU(sigma). Тогда если какая-то из сигм уходит в ноль, данный вес сети становится детерминированным: есть надежда, что можно ставить большой параметр изначально, а по ходу обучения сеть будет потихоньку "детерминировать" веса.

7) **Prioritized Experience Replay**. Более умный выбор сэмплов из ER - важная и интересная тема, но отправная точка, Prioritized Experience Replay, содержит в себе ряд костылей. Но основная идея вполне разумна: важность transition-а - значение лосса на нём, но пересчитывать эту важность онлайн получается только для текущего батча (пересчитывать на каждом шаге для большего числа транзишнов - означает проход вперёд по сети, то есть это дорого). Можно попробовать придумать другую важность для transition-ов или сэмплировать равномерно, и использовать важность как веса. Кажется, тогда получится динамическая функция потерь, сначала (x - y)**4, а потом падающая до (x - y)**2 или даже хубера...

8) **Backward Experience Replay**. Оказалось рабочей идей: мы же хотим распространить Q(s, a) от состояний, в которых игра закончилась (и где мы знаем точный сэмпл из Q(s,a), не зависящий от выхода нашей сети), к первым состояним игры. Давайте запишем транзишны в ER по играм, и будем ходить по ним в обратном порядке, от последних транзишнов к первым (доходим до первого - снова выбираем рандомную игру из памяти). Батч из 32 транзишнов - значит, можем параллельно ходить по 32 играм прошлого. Естественно, это работает только если отключить эвристику target-network, что приводит к дестабилизации классического DQN, но вот Categorical DQN без таргет-сети легко обходится по изначальной задумке, и с ним эта штука как-то работает.

9) **GAE on DQN**. Классический DQN использует одношагавую аппроксимацию: Q(s, a) <-- r + V(s'). n-step DQN, соответственно, n-шаговую. Rainbow вот тоже рекомендует юзать n=2 или n=3, потому что чем выше n, тем, по идее, ускоряется распространение Q(s,a) от последних состояний к первым. Но высокое значение n, ест-но, приводит к жуткой нестабильности. GAE в policy-gradient методах предлагает ансамблировать 1-шаговую, 2-шаговую ... n-шаговую аппроксимацию, и кажется, это вполне совместимо с Experience Replay-ем.

10) **Dynamic n-step DQN**. По идее, n должно быть большим в начале и равнятся 1 когда Q-функция уже точная, то есть в конце, и было бы здорово придумать способ его динамического уменьшения. В конце концов, предложить расписание как гиперпараметр: проблема тут в том, что динамическое изменение n вызывает вопрос о хранении транзишнов в experience replay.

11) **Quantile Rainbow**. Если Qunatile Regression DQN является улучшением Categorical DQN, может, надо взять Rainbow и "обновить"? Ага, DeepMind как раз сейчас над этим работает...

12) **Policy Gradient + DQN**. Как заансамблировать, скажем, actor-critic и DQN-based алгоритмы? Ну, простая идея - использовать Q^*(s, a) как фичи для actor-critic сети, обучая актёра, критика и Q-сеть паралелльно, возможно, даже, с общим Feature Extractor. Якобы на эту тему есть статьи: PGQL (2016, не слышал...), Reactor (2017 - а вот про это слышал)

13) **Bayesian DQN**. Байеса вроде применяют к RL, но вот просто взять и заменить нейросеть на байесовскую - пока не видел, а странно: поначалу сэмплов у нас из игр очень мало, а параметров много, и байес тут может очень пригодится, а главное, заменить exploration. Более того, "крутейшая" стратегия исследований, Noisy Nets, это эвристика в стиле костылей, когда "байесовская сеть" делает практически тоже самое, только с полным теоретическим обоснованием.

14) **Curiocity**. Любопытная тема сама по себе: предлагается, например, по s и s' предсказывать действие a, которое привело из s в s', и таким образом оценивать новизну действия a в состоянии s. "Новизна" добавляется к награде агента и поощряет исследовать среду, якобы позволяя решать суперсложные задачи. Вопрос - VAE из s в s', кажется, будет иметь не больше параметров, но, поскольку задача восстановления s' более сложная, эта "награда за любопытство" тоже будет менее тривиальная. В общем, можно поискать ещё определения любопытства, впрочем, на эту тему последнее время выходила огромная куча статей.

15) **Initialisation**. Есть подозрение, что инициализация сети играет огромную роль при обучении. Например, ортогональная инициализация сети в A2C ускорила обучение раза в два. Может, нужно использовать ортогонализированный оптимизатор (сохраняющий ортогональность всех матриц линейных слоёв - есть такие, якобы очень крутые) или вообще просто по-хитрому инициализировать процесс обучения?

16) **Optimization**. Ptan-овские оптимизации показыают, что Rainbow возможно неплохо ускорять за счёт разных фокусов, например, разделения игры и обучения сети на разные потоки. Prioritized Experience Replay можно ускорить, использую sum-tree структуру, предлагаемую ещё в исходной статье; Noisy Net, возможно, можно ускорить, выделив генерацию шума в отдельный поток. Ещё бы уметь всё это делать... Но есть и более приземлённый способы: есть подозрение, что Noisy Net можно ускорить через local reparametrization trick.

17) **Rainbow Actor-Critic**. А можно ли улучшения DQN, использующиеся в радуге, использовать, скажем, в A2C? Сходу: n-step используется по факту по определению, dueling - можно подумать, noisy - очень можно подумать, categorical (или QR теперь уже?) - вполне можно подумать, double - точно не нужно, prioritized replay - нужен off-policy A2C тогда, но такие вариации вроде есть.

18) **K-FAC DQN** TRPO и друзьяшки предлагает оптимизировать актёра в policy-gradient алгоритмах натуральным градиентом, мотивируя это тем, что нейросеть моделирует распределение. В DQN это не так, но в Categorical DQN и Quantile Regression DQN - так! Так, может...

19) **QR-DQN Reparametrization**. В статье по QR-DQN активно забивается на тот факт, что квантили t_0 ... t_N - не просто произвольные вещественные числа, а t_0 <= t_1 <= ... <= t_N. Возможно, это можно учесть в архитектуре сети. Особенно радует, что в отличии от Categorical DQN авторы не предоставили визуализации этих квантилей, есть подозрение, что именно по этой причине. А может, они пробовали учесть это в архитектуре, но ничего не заработало))

20) **Bayesian RL**. Пусть theta - веса нейросети для оптимальной (!) стратегии. Пусть есть прайор p(theta). Пока ни одной игры не сыграли - это и есть наш ответ. Генерируем стратегию pi ~ p(theta)), играем, ну допустим, один шаг в игре делаем. Получаем много величин: s_0, a_0, s_1, r(s_1), done(s_1) - ну, последние две, скажем, детерминированные. Пусть мы живём в мире Байеса - всё случайно, наша новая информация в этих новых переменных даёт нам какую-то инфу об уточнении распределения p(theta). Вот по какой формуле? Чему равна p(theta | pi, s_0, a_0, s_1, r(s_1), done(s_1)) в мире Байеса? Задача в RL поставлена определённым фиксированным образом, и по идее, нам тут не должно требоваться вводить вероятностную модель, нужно лишь понять, как в вероятностной модели "учитывается" оптимальность theta*. То есть p(pi | theta*) = p(E R(pi) = maxR), где maxR мы не знаем, но может ввести как ещё один параметр вероятностной модели и на него тоже делать байесовский вывод. Вот мне пока неясно, какая формула в этой задаче у p(theta | ...) после, самое простое, одного шага, но принципы Байеса говорят, что эта формула есть.
